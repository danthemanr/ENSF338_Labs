1. The `timeit.timeit()` function takes the sum of all of its measurements, meaning that any outliers should hopefully have negligible effects on the mean measurement. `timeit.timeit()` is the right function to use if all that you want is the mean.  
The `timeit.repeat()` function groups its measurements into various sums. this means that if the processor starts allocating more processing power to python, you could see a change across the groups. `timeit.repeat()` also gives you multiple values, so you can do stats stuff like variance.  
`timeit.timeit()` is better as a quick simple benchmark or if there's not that much noise; `timeit.repeat()` is good if you want to get an idea of what the variance of the times is (but you could just use `timeit.timeit()` with list comprehension to get a very similar effect).
2. You could compute the _average_ with the returned list from `timeit.repeat()`, but `timeit.timeit()` returns a sum, which is easier to turn into an _average_. If you wanted the _max_, then you should use `timeit.repeat()`, but the _max_ by itself isn't very helpful, as there's a lot of things that could make a system run worse. `timeit.repeat()` could be used to find the _min_; the min gives you a pretty good idea of how long the code actually take to execute because the _min_ usually happen when other processes aren't distracting the processor as much.